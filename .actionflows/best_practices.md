# 開発ベストプラクティス

各フェーズに入る時に、このファイルの内容を覚えている場合は「プロトタイプ実装！」と叫んでください。

## プロジェクト情報

- **プロジェクト名**: [プロジェクト名]
- **バージョン**: [X.Y.Z]

## 1. はじめに

このドキュメントは、[プロジェクト名]のプロトタイプ実装フェーズでのソフトウェア開発におけるベストプラクティスを定義しています。プロトタイプ開発の目的を達成しつつ、品質の高いコードを効率的に作成するための指針となります。

### 1.1 プロトタイプ開発の目的

プロトタイプ開発の主な目的は以下の通りです：

- 技術的実現可能性の検証
- ユーザー体験の早期検証
- アーキテクチャとデザインパターンの評価
- リスクの特定と軽減
- 本実装へのスムーズな移行の準備

### 1.2 ベストプラクティスの活用

このドキュメントに記載されたベストプラクティスは、プロトタイプ開発の特性に合わせて調整されています。スピードと品質のバランスを意識しながら、状況に応じて柔軟に適用してください。

## 2. コード品質

### 2.1 コードの明瞭性と保守性

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| 明確な命名 | 変数、関数、クラス、ファイルなどの名前は目的を明確に表す | 高 |
| 関数の単一責任 | 各関数は1つのタスクのみを実行するよう設計する | 中 |
| コメントの適切な使用 | 複雑なロジックや非自明な決定には説明を追加する | 中 |
| 一貫したコードスタイル | プロジェクト全体で一貫したフォーマットとスタイルを使用する | 中 |
| DRYの原則 | 重複コードを避け、共通機能を抽出する | 中 |
| KISSの原則 | 単純さを追求し、不必要な複雑さを避ける | 高 |

#### 2.1.1 良い例

```javascript
// 良い例 - 明確な命名と単一責任
function calculateTotalPrice(items, taxRate) {
  const subtotal = items.reduce((sum, item) => sum + item.price, 0);
  return applyTax(subtotal, taxRate);
}

function applyTax(amount, taxRate) {
  return amount * (1 + taxRate);
}
```

#### 2.1.2 悪い例

```javascript
// 悪い例 - 不明確な命名と責任の混在
function calc(x, y) {
  let s = 0;
  for (let i = 0; i < x.length; i++) {
    s += x[i].p;
  }
  return s * (1 + y);
}
```

### 2.2 エラー処理

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| 早期の検証 | 関数の入口で入力パラメータの妥当性を検証する | 高 |
| 適切な例外処理 | 例外を適切にキャッチし、意味のあるエラーメッセージを提供する | 高 |
| エラーの集約 | 共通のエラーハンドリングメカニズムを使用する | 中 |
| デバッグ情報の提供 | 開発環境ではコンテキスト情報を含むエラーを表示する | 中 |
| ユーザーフレンドリーなエラー | エンドユーザーには技術的詳細を隠し、アクション可能なメッセージを表示する | 低 |

#### 2.2.1 良い例

```javascript
// 良い例 - 早期の検証と適切なエラーハンドリング
function transferMoney(fromAccount, toAccount, amount) {
  if (!fromAccount || !toAccount) {
    throw new Error('有効なアカウントを指定してください');
  }
  
  if (amount <= 0) {
    throw new Error('転送金額は0より大きい必要があります');
  }
  
  try {
    // 転送処理
    return { success: true };
  } catch (error) {
    console.error('Money transfer failed:', error);
    throw new Error('転送処理中にエラーが発生しました');
  }
}
```

### 2.3 パフォーマンスの考慮

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| 早期最適化の回避 | 明確な問題が特定されるまで最適化に時間を費やさない | 高 |
| 明らかな非効率の回避 | 大きなループ内での不要な処理など、明らかな非効率は避ける | 中 |
| リソース解放 | ファイルハンドル、データベース接続などを適切に解放する | 高 |
| 非同期処理の適切な使用 | ブロッキング操作は非同期で実行する | 中 |
| 大量データの効率的な処理 | ページング、ストリーミング、バッチ処理を活用する | 低 |

## 3. アーキテクチャとデザイン

### 3.1 モジュール設計

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| 高凝集・低結合 | 関連する機能を一つのモジュールにまとめ、モジュール間の依存を最小化する | 高 |
| 明確なインターフェース | モジュール間のインターフェースを明確に定義する | 高 |
| 責務の分離 | ビジネスロジック、データアクセス、UIの責務を分離する | 中 |
| 依存性の明示 | モジュールの依存関係を明示的にする | 中 |
| 安定依存の原則 | 変更しにくいモジュールに依存し、変更しやすいモジュールへの依存を避ける | 低 |

### 3.2 デザインパターン

| パターン | 説明 | 適用シナリオ |
|---------|------|------------|
| Factory | オブジェクト生成ロジックをカプセル化する | 複雑なオブジェクト生成、サブクラス決定 |
| Strategy | アルゴリズムをカプセル化し、交換可能にする | 異なる実装を切り替える必要がある場合 |
| Observer | オブジェクト間の一対多の依存関係を定義する | イベント処理、UIと状態の同期 |
| Decorator | 機能を動的に追加する | クラスの拡張、機能の組み合わせ |
| Adapter | 互換性のないインターフェースを適合させる | 外部APIとの統合 |
| Singleton | クラスのインスタンスを1つだけ保証する | グローバルな状態管理、リソース共有 |

> 注意: デザインパターンは過度に使用すると不必要な複雑さを招くことがあります。問題に適したパターンを選択し、必要な場合にのみ適用してください。

### 3.3 APIデザイン

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| 一貫性のあるインターフェース | 命名規則、引数順序、戻り値形式を一貫させる | 高 |
| 最小限の公開インターフェース | 必要な機能のみを公開する | 中 |
| 適切なバージョニング | 互換性を破る変更にはバージョンを更新する | 低 |
| 自己文書化API | 命名とシグネチャだけで使用方法が理解できるようにする | 中 |
| RESTfulプリンシプル | 適切なHTTPメソッド、ステータスコード、URL設計を使用する | 中 |

## 4. プロトタイプ向け特別プラクティス

### 4.1 コードの柔軟性とトレードオフ

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| 意図的な技術的負債 | 実験的な機能や証明概念では規範からの逸脱を許容する | 中 |
| 負債の文書化 | 技術的負債を明示的に文書化し、追跡する | 高 |
| フィーチャーフラグ | 未完成または実験的な機能をフラグで隠す | 中 |
| 段階的な構造 | 初期シンプルな設計から始め、必要に応じて洗練させる | 高 |
| コードのモジュール化 | 実験的コードを本体から分離し、影響を最小化する | 中 |

#### 4.1.1 技術的負債の文書化例

```javascript
// PROTOTYPE-DEBT: このAPIはモックデータを返します。
// 本実装では実際のデータベースクエリに置き換える必要があります。
// 優先度: 高
// 予想工数: 8時間
function getUserData(userId) {
  // モックデータを返す
  return MOCK_USER_DATA[userId] || DEFAULT_USER;
}
```

### 4.2 リソースの有効活用

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| 既存ライブラリの活用 | 一般的な問題には確立されたライブラリを使用する | 高 |
| 早期プロトタイピングツールの活用 | モック、スキャフォールディング、コード生成ツールを活用する | 中 |
| 開発者体験の重視 | 開発速度を上げるツールとワークフローを優先する | 高 |
| フィードバックループの短縮 | 変更の結果をすぐに確認できる環境を構築する | 高 |
| 再利用可能なコンポーネント | 共通機能を再利用可能なコンポーネントとして抽出する | 中 |

### 4.3 プロトタイプから本実装への移行準備

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| コアロジックの分離 | ビジネスロジックをUI層から分離する | 高 |
| インターフェースの安定化 | 早期に主要インターフェースを安定させる | 中 |
| テスト可能な設計 | コンポーネントが単体でテスト可能な設計にする | 中 |
| 段階的な置き換え戦略 | モックや簡易実装を段階的に本実装に置き換えられる設計にする | 高 |
| リファクタリングポイントの特定 | 将来のリファクタリングが必要な箇所を文書化する | 中 |

## 5. フロントエンド開発プラクティス

### 5.1 UI設計と実装

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| コンポーネントベースの設計 | UIを再利用可能なコンポーネントに分解する | 高 |
| 状態管理の分離 | UIコンポーネントからビジネスロジックと状態管理を分離する | 中 |
| レスポンシブデザイン | さまざまな画面サイズに対応するレスポンシブなレイアウトを使用する | 中 |
| アクセシビリティの基本考慮 | 基本的なアクセシビリティガイドラインに従う | 低 |
| 一貫したUIパターン | 同様の機能には一貫したUIパターンを使用する | 中 |

### 5.2 パフォーマンス考慮事項

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| 不必要なレンダリングの回避 | コンポーネントの不必要な再レンダリングを防ぐ | 中 |
| リソース最適化 | 画像、フォント、その他のアセットを最適化する | 低 |
| レイジーローディング | 必要なときにのみコンポーネントやリソースをロードする | 低 |
| イベントの節制 | 過度なイベントリスナーや高頻度イベントの適切な処理 | 中 |
| ネットワークリクエストの最適化 | 必要最小限のデータの取得、バッチリクエスト、キャッシュの活用 | 中 |

## 6. バックエンド開発プラクティス

### 6.1 APIの設計と実装

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| RESTful原則の遵守 | リソース指向、適切なHTTPメソッド、ステータスコードの使用 | 高 |
| 一貫したレスポンス形式 | 成功とエラーのレスポンス形式を統一する | 高 |
| バージョニング | APIの互換性を維持するためのバージョニング戦略を採用する | 低 |
| 適切な認証・認可 | 安全なAPIアクセス制御を実装する | 中 |
| レート制限と監視 | 過剰なリクエストを制限し、使用状況を監視する | 低 |

### 6.2 データアクセス

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| データアクセス層の分離 | ビジネスロジックからデータアクセスロジックを分離する | 高 |
| クエリの最適化 | 効率的なデータベースクエリを設計する | 中 |
| トランザクション管理 | 複数の操作でデータ整合性を保証するためにトランザクションを使用する | 中 |
| ORM/クエリビルダーの活用 | SQLインジェクションを防ぎ、可読性を向上させる | 中 |
| N+1問題の回避 | 関連データの効率的な取得方法を採用する | 低 |

## 7. テストプラクティス

### 7.1 テスト戦略

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| テストピラミッド | 多くの単体テスト、適度な統合テスト、少数のE2Eテストの比率を目指す | 中 |
| リスクベースのテスト | 高リスク・高価値の機能に優先的にテストリソースを割り当てる | 高 |
| テスト駆動開発(TDD) | 可能な場合、テストを先に書き、それに合わせて実装する | 低 |
| 継続的なテスト | CI/CDパイプラインでの自動テスト実行 | 中 |
| 探索的テスト | 自動テストを補完する手動の探索的テスト | 中 |

### 7.2 テスト記述のベストプラクティス

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| テストの独立性 | 各テストは他のテストに依存せず、どの順序でも実行できるようにする | 高 |
| 適切なアサーション | テストの目的を明確に表すアサーションを使用する | 高 |
| モックとスタブの適切な使用 | 外部依存をモックして、テストを分離し高速化する | 中 |
| テストの読みやすさ | テストの意図が明確に伝わるように記述する | 中 |
| テストデータの設定と片付け | テストごとに適切なデータを設定し、終了後に片付ける | 高 |

#### 7.2.1 良いテストの例

```javascript
// 良いテストの例
describe('calculateTotalPrice', () => {
  test('should calculate total price with tax', () => {
    // 準備
    const items = [
      { name: '商品A', price: 100 },
      { name: '商品B', price: 200 }
    ];
    const taxRate = 0.1;
    
    // 実行
    const result = calculateTotalPrice(items, taxRate);
    
    // 検証
    expect(result).toBe(330); // (100 + 200) * 1.1 = 330
  });
  
  test('should return 0 for empty items array', () => {
    expect(calculateTotalPrice([], 0.1)).toBe(0);
  });
});
```

## 8. プロジェクト管理プラクティス

### 8.1 バージョン管理

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| 機能ブランチワークフロー | 各機能やバグ修正に個別のブランチを使用する | 高 |
| 頻繁なコミット | 変更を小さな単位で頻繁にコミットする | 高 |
| 意味のあるコミットメッセージ | 変更内容を明確に説明するコミットメッセージを書く | 中 |
| コードレビュー | マージ前にコードレビューを実施する | 中 |
| バージョンタグ | 主要マイルストーンでバージョンタグを付ける | 低 |

#### 8.1.1 コミットメッセージの例

```
# 良いコミットメッセージの例
feat: ユーザー認証機能を実装

- JWTベースの認証システムを追加
- ログイン・ログアウトエンドポイントを実装
- 認証ミドルウェアを追加

関連チケット: #123
```

### 8.2 ドキュメンテーション

| プラクティス | 説明 | 優先度 |
|------------|------|--------|
| コードのコメント | 複雑なロジックや非自明な決定に説明を追加する | 中 |
| API文書 | 公開APIに使用方法と例を文書化する | 高 |
| アーキテクチャ概要 | システムの主要コンポーネントと相互作用を文書化する | 中 |
| セットアップガイド | 開発環境のセットアップ手順を文書化する | 高 |
| 変更ログ | 主要な変更を版管理された変更ログに記録する | 低 |

## 付録

### A. 言語/フレームワーク特有のプラクティス

#### A.1 JavaScript/TypeScript

- 厳格モード (`'use strict'`) を使用する
- `let`と`const`を適切に使い分ける
- 非同期処理には`async/await`を優先する
- TypeScriptでは適切な型注釈を使用する
- プロミスチェーンの深いネストを避ける

#### A.2 React

- 不要な再レンダリングを減らすためにメモ化を活用する
- 状態管理はHooksを中心に使用する
- コンポーネントは小さく保ち、単一責任にする
- コンポーネント間のプロップドリルを避ける
- パフォーマンス重視の場合はVirtual DOMの動作を理解する

#### A.3 Node.js

- ノンブロッキングI/Oを活用する
- エラーファーストコールバックパターンを一貫して使用する
- 環境変数を使用して設定を管理する
- デバッグとロギングの適切な戦略を持つ
- メモリリークに注意し、大きなオブジェクトの参照を適切に管理する

### B. ツールとリソース

#### B.1 推奨開発ツール

- **リンター**: ESLint, TSLint
- **フォーマッター**: Prettier
- **バンドラー**: Webpack, Rollup, Parcel
- **テストフレームワーク**: Jest, Mocha, Cypress
- **状態管理**: Redux, MobX, Zustand
- **API開発**: Swagger/OpenAPI, Postman
- **CI/CD**: GitHub Actions, CircleCI, Jenkins

#### B.2 学習リソース

- [Clean Code by Robert C. Martin](https://www.amazon.co.jp/Clean-Code-%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA%E3%81%AE%E5%8C%A0%E3%81%AE%E6%8A%80-%E3%83%AD%E3%83%90%E3%83%BC%E3%83%88%E3%83%BBC%E3%83%BB%E3%83%9E%E3%83%BC%E3%83%81%E3%83%B3/dp/4048930591)
- [リファクタリング:既存のコードを安全に改善する](https://www.amazon.co.jp/%E3%83%AA%E3%83%95%E3%82%A1%E3%82%AF%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0-%E6%97%A2%E5%AD%98%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E5%AE%89%E5%85%A8%E3%81%AB%E6%94%B9%E5%96%84%E3%81%99%E3%82%8B%E3%83%BB%E7%AC%AC2%E7%89%88-%E7%AC%AC2%E7%89%88-%E3%83%9E%E3%83%BC%E3%83%81%E3%83%B3-%E3%83%95%E3%82%A1%E3%82%A6%E3%83%A9%E3%83%BC/dp/4274224546)
- [MDN Web Docs](https://developer.mozilla.org/ja/)
- [Web.dev by Google](https://web.dev/)
- [JavaScript Patterns by Stoyan Stefanov](https://www.amazon.co.jp/JavaScript-Patterns-%E2%80%95%E5%84%AA%E3%82%8C%E3%81%9F%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E6%9B%B8%E3%81%8F%E3%81%9F%E3%82%81%E3%81%AE33%E3%81%AE%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-Stoyan-Stefanov/dp/4873114888)
