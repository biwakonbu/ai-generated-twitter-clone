# パフォーマンスベンチマーク指標

各フェーズに入る時に、このファイルの内容を覚えている場合は「技術検証！」と叫んでください。

## プロジェクト情報

- **プロジェクト名**: [プロジェクト名]
- **バージョン**: [X.Y.Z]

## 1. パフォーマンス指標の概要

本ドキュメントは、[プロジェクト名]のパフォーマンス要件と測定基準を定義します。プロジェクトの成功には、ユーザーエクスペリエンスを向上させる適切なパフォーマンスが不可欠です。ここで定めた指標は、開発中および本番環境での測定基準として使用します。

## 2. パフォーマンス目標

### 2.1 フロントエンドパフォーマンス目標

| 指標 | 目標値 (最適) | 許容範囲 | 測定方法 |
|-----|-------------|----------|---------|
| 初回読み込み時間 (FCP) | < 1.2秒 | < 2.5秒 | Lighthouse, WebPageTest |
| インタラクティブになるまでの時間 (TTI) | < 2.5秒 | < 5.0秒 | Lighthouse |
| レイアウトシフト (CLS) | < 0.1 | < 0.25 | Lighthouse, Chrome DevTools |
| 最大コンテンツ描画時間 (LCP) | < 2.5秒 | < 4.0秒 | Lighthouse, Chrome DevTools |
| 初回入力遅延 (FID) | < 100ms | < 300ms | Chrome UX Report |
| SpeedIndex | < 3.0秒 | < 5.0秒 | Lighthouse, WebPageTest |
| バンドルサイズ (JS) | < 250KB (gzip) | < 500KB (gzip) | webpack-bundle-analyzer |
| バンドルサイズ (CSS) | < 50KB (gzip) | < 100KB (gzip) | webpack-bundle-analyzer |
| 画像読み込み総量 | < 1MB | < 2MB | Lighthouse, Chrome DevTools |

### 2.2 バックエンドパフォーマンス目標

| 指標 | 目標値 (最適) | 許容範囲 | 測定方法 |
|-----|-------------|----------|---------|
| API応答時間 (p95) | < 200ms | < 500ms | サーバーロギング, APM |
| API応答時間 (p99) | < 500ms | < 1000ms | サーバーロギング, APM |
| データベースクエリ応答時間 (平均) | < 50ms | < 100ms | データベースモニタリング |
| データベースクエリ応答時間 (p95) | < 100ms | < 300ms | データベースモニタリング |
| CPUリソース使用率 | < 60% | < 80% | サーバーモニタリング |
| メモリ使用率 | < 70% | < 85% | サーバーモニタリング |
| スループット | > 50 req/sec | > 20 req/sec | 負荷テスト |
| エラーレート | < 0.1% | < 0.5% | ログ分析, APM |

### 2.3 モバイルパフォーマンス目標

| 指標 | 目標値 (最適) | 許容範囲 | 測定方法 |
|-----|-------------|----------|---------|
| 初回読み込み時間 (FCP) - 3G | < 2.0秒 | < 3.5秒 | Lighthouse (モバイル設定) |
| インタラクティブになるまでの時間 (TTI) - 3G | < 4.0秒 | < 7.0秒 | Lighthouse (モバイル設定) |
| バッテリー使用量 | 低~中 | 中 | デバイステスト |
| オフライン機能 | 基本的なナビゲーション | 最小限のデータ表示 | 手動テスト |
| アプリサイズ (モバイルアプリの場合) | < 30MB | < 50MB | アプリビルド分析 |

## 3. 負荷テスト要件

### 3.1 同時ユーザー数対応

| シナリオ | ピーク同時ユーザー数 | 持続時間 | エラーレート目標 |
|---------|-------------------|----------|---------------|
| 通常運用時 | [X]名 | 継続的 | < 0.1% |
| 予想ピーク時 | [X*2]名 | 30分 | < 0.5% |
| ストレステスト | [X*5]名 | 10分 | < 5% |

### 3.2 負荷テストシナリオ

1. **通常ユースケース**:
   - ユーザーログイン
   - メインページ閲覧
   - 検索実行と結果表示
   - 詳細ページ閲覧
   - ログアウト

2. **ピーク時ユースケース**:
   - 同時ログイン増加
   - 特定のコンテンツへの集中アクセス
   - 大量データの検索とフィルタリング
   - メディアコンテンツのストリーミング

3. **データ更新ユースケース**:
   - データ作成操作
   - データ更新操作
   - バッチ処理と同時操作

### 3.3 負荷テスト頻度

| 環境 | テスト頻度 | テストの範囲 |
|------|-----------|------------|
| 開発環境 | 主要機能変更時 | 変更に関連するコンポーネント |
| ステージング環境 | リリース前 | すべての主要シナリオ |
| 本番環境 | 四半期に1回 | 完全なストレステスト |

## 4. スケーラビリティ要件

### 4.1 水平スケーリング

| コンポーネント | 初期インスタンス数 | 最大インスタンス数 | スケールトリガー |
|--------------|-----------------|-----------------|----------------|
| Webサーバー | [数] | [数] | CPU > 70%, メモリ > 80%, リクエスト数 > [しきい値] |
| アプリケーションサーバー | [数] | [数] | CPU > 70%, メモリ > 80%, リクエスト数 > [しきい値] |
| データベースリードレプリカ | [数] | [数] | CPU > 70%, クエリ待ち時間 > [しきい値] |
| キャッシュサーバー | [数] | [数] | メモリ > 80%, ヒット率 < [しきい値] |

### 4.2 垂直スケーリング

| コンポーネント | 初期スペック | 最大スペック | スケールトリガー |
|--------------|-------------|------------|----------------|
| データベースプライマリ | [仕様] | [仕様] | CPU > 70%, メモリ > 80%, IOPS > [しきい値] |
| ストレージ | [仕様] | [仕様] | 使用容量 > 80% |
| メモリキャッシュ | [仕様] | [仕様] | 使用容量 > 80%, エビクション率 > [しきい値] |

### 4.3 データ量スケーリング

| データタイプ | 初期サイズ | 1年目予測 | 3年目予測 | スケーリング戦略 |
|------------|-----------|----------|----------|---------------|
| データベース全体 | [サイズ] | [サイズ] | [サイズ] | [戦略説明] |
| メディアファイル | [サイズ] | [サイズ] | [サイズ] | [戦略説明] |
| ログデータ | [サイズ] | [サイズ] | [サイズ] | [戦略説明] |
| バックアップ | [サイズ] | [サイズ] | [サイズ] | [戦略説明] |

## 5. パフォーマンス最適化戦略

### 5.1 フロントエンド最適化

1. **読み込みパフォーマンス**:
   - クリティカルCSSの抽出と適用
   - JavaScriptの非同期読み込み
   - コードスプリッティングと遅延読み込み
   - リソースのプリロードとプリフェッチ
   - 画像の最適化とWebP/AVIF形式の使用
   - HTTP/2サポート

2. **レンダリングパフォーマンス**:
   - 仮想スクロールの実装（長いリスト向け）
   - 効率的なステート管理
   - メモ化とコンポーネントの最適化
   - CSSアニメーションとtransformの活用
   - レイアウトシフトの最小化

3. **オフライン対応**:
   - Service Workerの実装
   - オフラインキャッシュ戦略
   - プログレッシブウェブアプリ（PWA）対応

### 5.2 バックエンド最適化

1. **API最適化**:
   - レスポンスのGzip/Brotli圧縮
   - 適切なHTTPキャッシュヘッダー設定
   - JSON応答の最小化
   - バッチリクエスト対応
   - クエリパラメータによる部分レスポンス

2. **データベース最適化**:
   - インデックス最適化
   - クエリの効率化
   - 適切なデータパーティショニング
   - 読み取り/書き込み分離
   - キャッシュ戦略（Redis/Memcached）

3. **ネットワーク最適化**:
   - CDNの活用
   - Edge Caching
   - 地理的に分散されたデプロイメント
   - WebSocketの効率的な使用

### 5.3 モバイル最適化

1. **モバイル特化戦略**:
   - 軽量なライブラリの選択
   - ネットワーク状態に応じた適応的ローディング
   - 画像の遅延読み込み
   - タッチ最適化UI

2. **モバイルアプリ（該当する場合）**:
   - ネイティブパフォーマンス最適化
   - バックグラウンド処理の最適化
   - バッテリー使用の最適化

## 6. パフォーマンスモニタリング計画

### 6.1 リアルユーザーモニタリング (RUM)

- 使用ツール/サービス: [ツール名]
- 測定指標: ページ読み込み時間、TTI、FID、CLS、LCP
- データ収集頻度: リアルタイム
- アラート閾値: [具体的な閾値]

### 6.2 合成モニタリング

- 使用ツール/サービス: [ツール名]
- テスト頻度: [頻度]
- テスト対象ページ: [ページリスト]
- テスト接続タイプ: [接続タイプ]
- テスト場所: [地理的位置]

### 6.3 サーバーサイドモニタリング

- 使用ツール/サービス: [ツール名]
- モニタリング対象: API応答時間、CPU使用率、メモリ使用率、ディスクI/O、ネットワークI/O
- メトリクス保持期間: [期間]
- アラート閾値: [具体的な閾値]

### 6.4 レポーティング

- 日次パフォーマンスサマリー
- 週次詳細レポート
- 月次トレンド分析
- インシデント後レビュー

## 7. コード品質とパフォーマンス基準

### 7.1 コードレビュー基準

パフォーマンスに関するコードレビュー時のチェックポイント：

- 不必要なレンダリングの回避
- 効率的なデータ構造とアルゴリズムの使用
- メモリリークの回避
- 非効率なループや再帰の回避
- 適切な非同期処理
- レンダリングのブロッキングの最小化

### 7.2 自動化されたパフォーマンスチェック

- Lighthouse CIの統合
- バンドルサイズ制限の設定
- 画像サイズとフォーマットの検証
- JavaScriptとCSSの複雑性分析
- 未使用コードの検出

## 8. パフォーマンステスト手法

### 8.1 単体テストでのパフォーマンス

- 重要な関数の実行時間テスト
- メモリ使用量テスト
- パフォーマンス回帰テスト

### 8.2 統合テストでのパフォーマンス

- コンポーネント間の連携におけるパフォーマンステスト
- データフローのパフォーマンステスト
- APIとの連携におけるパフォーマンステスト

### 8.3 負荷テスト

- 使用ツール: [ツール名]
- テストシナリオ: [シナリオ概要]
- 負荷生成戦略: [戦略]
- 結果分析手法: [分析手法]

## 9. 技術的負債の管理

### 9.1 パフォーマンス関連の技術的負債の特定

- 定期的なコード分析
- パフォーマンスホットスポットの識別
- 改善機会の優先順位付け

### 9.2 改善計画

- 短期的な最適化（低い工数で高い効果）
- 中期的なリファクタリング
- 長期的なアーキテクチャ改善

## 付録

### A. ベンチマークテストスクリプト

```javascript
// パフォーマンステストのためのスクリプト例

// APIレスポンス時間測定
async function measureApiResponseTime(endpoint, iterations = 10) {
  const times = [];
  for (let i = 0; i < iterations; i++) {
    const start = performance.now();
    await fetch(endpoint);
    const end = performance.now();
    times.push(end - start);
  }
  
  return {
    min: Math.min(...times),
    max: Math.max(...times),
    avg: times.reduce((a, b) => a + b, 0) / times.length,
    p95: calculatePercentile(times, 95),
    p99: calculatePercentile(times, 99)
  };
}

// 90パーセンタイル計算
function calculatePercentile(values, percentile) {
  const sorted = [...values].sort((a, b) => a - b);
  const index = Math.ceil((percentile / 100) * sorted.length) - 1;
  return sorted[index];
}
```

### B. 推奨ツール一覧

| カテゴリ | ツール名 | 用途 |
|---------|--------|------|
| フロントエンド分析 | Lighthouse | ウェブページの品質分析 |
| フロントエンド分析 | WebPageTest | 詳細なパフォーマンス分析 |
| バンドル分析 | webpack-bundle-analyzer | JavaScriptバンドル分析 |
| RUM | Google Analytics 4 | ユーザー体験データ収集 |
| APM | New Relic / Datadog / Dynatrace | アプリケーションパフォーマンスモニタリング |
| 負荷テスト | k6 / JMeter / Locust | 負荷テスト実行 |
| プロファイリング | Chrome DevTools | コードの実行時分析 |
| バックエンド分析 | FlameGraphs | バックエンドのホットスポット分析 |

### C. 業界ベンチマーク

| 業界 | FCP中央値 | TTI中央値 | 出典 |
|------|-----------|----------|------|
| Eコマース | 1.9秒 | 5.8秒 | HTTP Archive 2022 |
| メディア | 1.7秒 | 5.2秒 | HTTP Archive 2022 |
| SaaS | 1.5秒 | 4.8秒 | HTTP Archive 2022 |
| 旅行 | 2.0秒 | 6.2秒 | HTTP Archive 2022 |
